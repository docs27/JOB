<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Jacks or Better</title>
<style>
    *{
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        user-select: none;   /* Standard property */
        -webkit-user-select: none; /* Chrome/Safari */
        -moz-user-select: none;    /* Firefox */
        -ms-user-select: none;     /* IE/Edge */
    }
    html{
        background-color: black;
        color: white;
        width: 100vw;
        height: 100vh;
    }
    body {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        font-family: system-ui, sans-serif;
        letter-spacing: .1rem; 
        background:darkblue;
        padding: 1rem;
        overflow: hidden;
    }
    .container {
        position: relative;
        width: 100%;
        min-width: 13rem;
        max-width: 62rem;
        overflow: hidden;
        /* background-color: greenyellow; */
        /* resize: horizontal; */
        /* overflow: auto; */
        /* background-color: red; */
        /* width: 90%; */
        /* margin-top: 2rem; */
        /* box-sizing: border-box; */
    }
    .title{
        font-size: 2rem;
        font-weight: bold;
        /* margin-top: 2rem; */
        /* color: white; */
    }
    .frame {
        /* width: 100%; */
        border: 1px solid yellow;
        border-radius: .5rem;
        padding: .2rem;
        background: rgba(0,0,0,.7);
        flex-shrink: 0;
    }
    
    table {
        border-collapse: collapse;
        width: 100%;
        height: 100%;
        color: yellow;
        border: none;
        line-height: 1rem;
        table-layout: fixed;
        white-space: nowrap;
    }

    table td {
        border: none;
        text-align: right;
    }
    table td:first-child {
        text-align: left;
        width: 48%;
    }
    .collapsed {
        display: none;

    }
    .highlight-row {
        background: rgba(255, 255, 255, 0.33);
    }
    .won-row{
        /* color: white; */
        font-weight: bold;
    }
    .highlight-col {
        background: rgba(255, 0, 0, .33);
    }

    .highlight-row.highlight-col {
        background: rgba(255, 0, 0, .66);
    }
    .banner{
        /* width: inherit; */
        white-space: nowrap;
        display:flex;
        /* justify-content: center; */
        /* align-items: center; */
        text-align: center;
        position: absolute;
        color: yellow;
        font-weight: bold;
        top: 50%;
        left: 50%;
        transform: translateX(-50%) translateY(-30%);
        font-size: 2rem;
        background-color: rgba(0,0,0,.7);
        backdrop-filter: blur(3px);
        padding: .5rem 1rem;
        border-radius: .5rem;
        border: solid 1px yellow;
        box-shadow: 10px 10px rgba(0,0,0,.3);
        z-index: 10;
    }
    .hidden{
        visibility: hidden;
    }
    .outlined{
        color: red;
        /* font-weight: bold; */
        text-shadow:
        1px 0 yellow,
        -1px 0 yellow,
        0 1px yellow,
        0 -1px yellow,
        1px 1px yellow,
        -1px -1px yellow,
        1px -1px yellow,
        -1px 1px yellow;
    }
    .hand {
        position: relative;
        display: flex;
        /* width: 100%; */
        justify-content: space-between;
        /* align-items: center;  */
        margin-top: 2rem;
        /* resize: horizontal; */
        /* overflow: hidden;  */
    }
    .hand.clickable .card {
        cursor: pointer;
        pointer-events: all;
    }
    .card {
        width: 12rem;
        height: 18rem;
        background: white;
        border-radius: .5rem;
        border: 1px solid rgb(100, 100, 100);
        padding: 10px;
        display: grid;
        grid-template-rows: auto 1fr auto;
        box-shadow: -2px 2px 0px rgba(0,0,0,.3);
        flex-shrink: 0;
        color: black;
    }

    .corner {
        display: flex;
        flex-direction: column;
        line-height: 2rem;
        /* background-color: aqua; */
    }

    .corner.bottom {
        transform: rotate(180deg);
        align-self: end;
    }

    .rank {
        font-size: 2.4rem;
        font-weight: bold;
    }

    .suit {
        font-size: 2.4rem;
    }

    .center {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 90px;
        /* background-color: blueviolet; */
    }

    /* Suit colors */
    .card.red {
        color: red;
    }
    .card.back {
        background-color: lightcoral;
        border: white solid 5px;
    }
    .card.held {
        /* box-shadow: none; */
        /* box-shadow: 0 1px 8px black; */
        /* transform: translateX(2px) translateY(2px); */
        transform: translateY(0px);
    }
    .card.held::before {
        content: "HELD";
        position: absolute;
        top: -10%;
        /* left: 50%; */
        /* transform: translateX(-50%); */
        transform: translateX(10%);
        color: white;
        font-size: 1rem;
        font-weight: bold;
    }
    td.flash {
        /* background-color: lawngreen; */
        /* animation: flashAnim 0.6s ease-in-out 0s 3; */
        animation: tdFlash 600ms ease-in-out infinite;
    }
    @keyframes tdFlash {
        50% { background: rgba(255, 255, 255, 0.66); }
    }
    .card.flash {
        /* background-color: lawngreen; */
        /* animation: flashAnim 0.6s ease-in-out 0s 3; */
        animation: cardFlash 600ms ease-in-out infinite;
    }
    @keyframes cardFlash {
        50% {box-shadow: 0 0 20px yellow; }
        /* 50% {border: solid 5px yellow} */
        /* 0%,100% { box-shadow: 0 0 0px yellow; transform: translateY(-10px) scale(1); } */
        /* 50% { box-shadow: 0 0 15px yellow; transform: translateY(-10px) scale(1.1); } */
    }
    .pulse {
        animation: pulseAnim 0.15s ease-in-out;
    }
    @keyframes pulseAnim {
        0% { transform: scale(1); color: gold; }
        50% { transform: scale(1.3); color: gold; }
        100% { transform: scale(1); color: gold; }
    }
    .stats{
        display:flex;
        font-weight: bold;
        font-size: 1.2rem;
        /* width: auto; */
        justify-content: space-between;
        /* margin: 1rem; */
        flex-shrink: 0;
    }
    .buttons{
        display: flex;
        justify-content: space-between;
        gap: 3%;
        padding-bottom: 4px;
        flex-shrink: 0;
    }
    button {
        padding: 8px 15px;
        min-width: 4rem;
        min-height: 4rem;
        font-size: 1rem;
        font-weight: bold; 
        cursor: pointer;
        background-color: yellow;
        border: none;
        border-radius: .5rem;
        flex:1;
        /* box-shadow: 3px 3px 0 rgb(100, 100, 0); */
        box-shadow: 0 4px 0 rgb(100, 100, 0);
    }
    button:disabled {
        cursor: not-allowed;
        background-color: darkgray;
        /* box-shadow: 3px 3px 0 gray; */
        box-shadow: 0px 4px 0 gray;
    }
    button:active {
        /* box-shadow: 1px 1px 0 gray; */
        box-shadow: 0 1px 0 gray;
        /* transform: translateX(2px) translateY(2px); */
        transform: translateY(3px);
    }
    .footer {
        font-size: .8rem;
        color: rgb(0,100,255);
    }
    a {
        text-decoration: none;
        color: rgb(0,100,255);
    }

    @media (max-width: 479px) or (max-height: 559px) {
        html {
            font-size: 14px;
        }
    }
    @media (max-width: 399px) or (max-height: 499px) {
        html {
            font-size: 12px;
        }
    }
    @media (max-width: 339px) or (max-height: 419px) {
        html {
            font-size: 10px;
        }
    }
    @media (max-width: 289px) or (max-height: 359px) {
        html {
            font-size: 8px;
        }
    }

</style>
</head>
<body>

<span class="title">JACKS or BETTER</span>
<!-- <p>Double Double Bonus</p> -->

<div class="container frame">
    <table id="paytable"></table>
</div>

<div class="container">
    <span class="banner" id="banner"></span>
    <div class="hand" id="hand"></div>
</div>

<div class="container stats">
    <span class="stat" id="win"></span>
    <!-- <span> Bet: <span id="bet"></span></span> -->
  <span class="stat" id="credits"></span>
</div>

<div class="container buttons">
  <button id="betOneBtn" disabled>BET ONE</button>
  <button id="betMaxBtn" disabled>BET MAX</button>
  <button id="dealBtn" disabled>DEAL</button>
  <button id="resetBtn" disabled>CASH OUT</button>
</div>
<div class="footer">
    User info: <span id="user-id">Loading...</span>, <span id="username">Loading...</span>, <span id="language">Loading...</span><br>
    Viewport data: <span>Loading...</span>, <span>Loading...</span>, <span>Loading...</span>, <span>Loading...</span><br>
    Created by: <a href="https://www.t.me/u002e">@u002E</a>; <span id="viewport"></span> 
</div>

<script src="https://telegram.org/js/telegram-web-app.js?59"></script>
<script>
    const tg = window.Telegram.WebApp
    if(tg){
        tg.ready()
        tg.expand()
    }

    function updateUserData(){
        if(!tg) return
        const user = tg.initDataUnsafe.user;
        document.getElementById('user-id').textContent = user.id || 'N/A';
        document.getElementById('username').textContent = user.username || 'N/A';
        document.getElementById('language').textContent = user.language_code || 'N/A'; 
    }

    function updateViewportSize(){
        if(!tg) return
        document.getElementById('viewport-fullscreen').textContent = tg.isExpanded;
        document.getElementById('viewport-height').textContent = tg.viewportHeight;
        document.getElementById('viewport-stable-height').textContent = tg.viewportStableHeight;
        document.getElementById('document-height').textContent = document.documentElement.scrollHeight;
    }

    let UI = {}

    const DEFAULTS = Object.freeze({  //  Read only object
        START_CREDITS: 100,
        MIN_BET: 1,
        MAX_BET: 5,
        SUITS: ["♥", "♦", "♣", "♠"],
        RANKS: ['A','2','3','4','5','6','7','8','9','10','J','Q','K'],
        VALUES: {
            '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, 
            '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14
        },
        HAND_SIZE: 5
    })
    
    const HAND_RANKS = Object.freeze({
        ROYAL_FLUSH: {
            name: "ROYAL FLUSH",
            payout: [250, 500, 750, 1000, 4000]
        },
        STRAIGHT_FLUSH: {
            name: "STRAIGHT FLUSH",
            payout: [50, 100, 150, 200, 250]
        },
        FOUR_ACES_WITH_ANY_2_3_4: {
            name: "FOUR ACES w/2, 3, or 4",
            payout: [400, 800, 1200, 1600, 2000]
        },
        FOUR_2s_3s_4s_W_OR_ACE_2_3_4: {
            name: "FOUR 2, 3, or 4 w/A-4",
            payout: [160, 320, 480, 640, 800]
        },
        FOUR_ACES: {
            name: "FOUR ACES",
            payout: [160, 320, 480, 640, 800]
        },
        FOUR_2s_3s_4s: {
            name: "FOUR 2, 3, or 4",
            payout: [80, 160, 240, 320, 400]
        },
        FOUR_5s_THRU_KINGS: {
            name: "FOUR 5-K",
            payout: [50, 100, 150, 200, 250]
        },
        FULL_HOUSE: {
            name: "FULL HOUSE",
            payout: [10, 20, 30, 40, 50]
        },
        FLUSH: {
            name: "FLUSH",
            payout: [6, 12, 18, 24, 30]
        },
        STRAIGHT: {
            name: "STRAIGHT",
            payout: [4, 8, 12, 16, 20]
        },
        THREE_OF_A_KIND: {
            name: "THREE OF A KIND",
            payout: [3, 6, 9, 12, 15]
        },
        TWO_PAIR: {
            name: "TWO PAIR",
            payout: [1, 2, 3, 4, 5]
        },
        JACKS_OR_BETTER: {
            name: "JACKS OR BETTER",
            payout: [1, 2, 3, 4, 5]
        },
    });

    const HAND_RULES = Object.freeze([
        // ROYAL FLUSH
        {
            rank: HAND_RANKS.ROYAL_FLUSH,
            priority: 1000,
            test: ctx =>
                ctx.isFlush &&
                ctx.sortedValues.toString() === "10,11,12,13,14",
            indexes: ctx => ctx.allIndexes
        },

        // STRAIGHT FLUSH
        {
            rank: HAND_RANKS.STRAIGHT_FLUSH,
            priority: 900,
            test: ctx => ctx.isFlush && ctx.isStraight,
            indexes: ctx => ctx.allIndexes
        },

        // FOUR ACES WITH ANY 2,3,4
        {
            rank: HAND_RANKS.FOUR_ACES_WITH_ANY_2_3_4,
            priority: 800,
            test: ctx => {
                const quad = ctx.uniqueValues.find(v => ctx.rankMap[v]?.length === 4);
                if (quad !== 14) return false;
                const kicker = ctx.uniqueValues.find(v => v !== quad);
                return [2, 3, 4].includes(kicker);
            },
            indexes: ctx => {
                const quad = ctx.uniqueValues.find(v => ctx.rankMap[v]?.length === 4);
                const kicker = ctx.uniqueValues.find(v => v !== quad);
                return [...ctx.rankMap[quad], ctx.rankMap[kicker][0]];
            }
        },

        // FOUR ACES
        {
            rank: HAND_RANKS.FOUR_ACES,
            priority: 750,
            test: ctx => ctx.rankMap[14]?.length === 4,
            indexes: ctx => ctx.rankMap[14] ?? []
        },

        // FOUR 2s, 3s, OR 4s
        {
            rank: HAND_RANKS.FOUR_2s_3s_4s,
            priority: 700,
            test: ctx => ctx.uniqueValues.some(v => [2, 3, 4].includes(v) && ctx.rankMap[v]?.length === 4),
            indexes: ctx => {
                const v = ctx.uniqueValues.find(v => [2, 3, 4].includes(v) && ctx.rankMap[v]?.length === 4);
                return ctx.rankMap[v] ?? [];
            }
        },

        // FOUR 5s THROUGH KINGS
        {
            rank: HAND_RANKS.FOUR_5s_THRU_KINGS,
            priority: 650,
            test: ctx => ctx.uniqueValues.some(v => v >= 5 && v <= 13 && ctx.rankMap[v]?.length === 4),
            indexes: ctx => {
                const v = ctx.uniqueValues.find(v => v >= 5 && v <= 13 && ctx.rankMap[v]?.length === 4);
                return ctx.rankMap[v] ?? [];
            }
        },

        // FULL HOUSE
        {
            rank: HAND_RANKS.FULL_HOUSE,
            priority: 600,
            test: ctx => ctx.counts.includes(3) && ctx.counts.includes(2),
            indexes: ctx => ctx.allIndexes
        },

        // FLUSH
        {
            rank: HAND_RANKS.FLUSH,
            priority: 500,
            test: ctx => ctx.isFlush,
            indexes: ctx => ctx.allIndexes
        },

        // STRAIGHT (supports Ace-low: A-2-3-4-5)
        {
            rank: HAND_RANKS.STRAIGHT,
            priority: 400,
            test: ctx => ctx.isStraight,
            indexes: ctx => ctx.allIndexes
        },

        // THREE OF A KIND
        {
            rank: HAND_RANKS.THREE_OF_A_KIND,
            priority: 300,
            test: ctx => ctx.counts.includes(3) && !ctx.counts.includes(2),
            indexes: ctx => {
                const v = ctx.uniqueValues.find(v => ctx.rankMap[v]?.length === 3);
                return ctx.rankMap[v] ?? [];
            }
        },

        // TWO PAIR
        {
            rank: HAND_RANKS.TWO_PAIR,
            priority: 200,
            test: ctx => ctx.counts[0] === 2 && ctx.counts[1] === 2,
            indexes: ctx => ctx.uniqueValues
                .filter(v => ctx.rankMap[v]?.length === 2)
                .sort((a, b) => b - a)
                .flatMap(v => ctx.rankMap[v])
        },

        // JACKS OR BETTER
        {
            rank: HAND_RANKS.JACKS_OR_BETTER,
            priority: 100,
            test: ctx => {
                // must be exactly one pair
                if (ctx.counts[0] !== 2 || ctx.counts[1] !== 1) return false;

                // that pair must be Jacks or higher
                return ctx.uniqueValues.some(
                    v => v >= 11 && ctx.rankMap[v]?.length === 2
                );
            },
            indexes: ctx => {
                const pairValue = ctx.uniqueValues
                    .filter(v => v >= 11 && ctx.rankMap[v]?.length === 2)
                    .sort((a, b) => b - a)[0];

                return pairValue ? ctx.rankMap[pairValue] : [];
            }
        }
    ]);

    const State = Object.seal({  //  This prevents adding/removing properties but allows value changes.
        isDeal: true,
        credits: DEFAULTS.START_CREDITS,  
        bet: DEFAULTS.MIN_BET,
        win: null,
        deck: [], 
        hand: [], 
        currentHandRank: null,
        wonIndices: []
    })

    function render(){
        highlightPaytable()
        UI.win.textContent=State.win>0?`WIN ${State.win}`:'NO WIN'
        UI.win.classList.toggle('hidden', State.win===null || !State.isDeal)

        if(State.win > 0) pulseCredits()
        else UI.credits.textContent=`CREDITS ${State.credits}`

        // let text = `PLAY ${State.bet} ${State.bet === 1 ? 'CREDIT' : 'CREDITS'}`
        // if (State.win && State.win > 0) {
        //     text = `YOU WON ${State.win} CREDITS<br>${text}`
        // }
        // UI.banner.innerHTML = text
        UI.banner.textContent = `PLAY ${State.bet} ${State.bet===1? 'CREDIT': 'CREDITS'}`
        
        UI.banner.classList.toggle('hidden', !State.isDeal)

        UI.betOneBtn.disabled=(!State.isDeal || State.credits <= 0)
        UI.betMaxBtn.disabled=(!State.isDeal || State.bet===DEFAULTS.MAX_BET || State.credits <= 0)

        UI.dealBtn.disabled=(State.credits <= 0 && State.isDeal)
        UI.dealBtn.textContent = State.isDeal ? 'DEAL' : 'DRAW'

        // UI.resetBtn.disabled=(!State.isDeal || State.credits <= 0)

        renderHand(State.hand)

        UI.hand.classList.toggle('clickable', !State.isDeal);

        if (State.isDeal && State.wonIndices.length > 0) {
            const cardDivs = UI.hand.children;
            const flashCards = State.wonIndices
                .map(i => cardDivs[i])
                .filter(Boolean);
            flashCards.forEach(el => el.classList.add("flash"));
            setTimeout(() => {
                flashCards.forEach(el => el.classList.remove("flash"));
            }, 3000);
        }    
    }

    function renderPaytable(handRanks){
        Object.values(handRanks).forEach(hand => {
            const row = document.createElement("tr");

            const nameCell = document.createElement("td");
            nameCell.textContent = hand.name;
            row.appendChild(nameCell);

            hand.payout.forEach(value => {
            const cell = document.createElement("td");
            cell.textContent = value;
            row.appendChild(cell);
            });

            UI.table.appendChild(row);
        });
    }
    
    function highlightPaytable(){      
        let activeHandIndex=Object.values(HAND_RANKS).findIndex(rank => rank.name === State.currentHandRank) 
        let activeBetIndex=State.bet

        const rows = [...UI.table.rows];
        const rowCells = [];
        const colCells = [];

        // Clear pervious & collect cells
        rows.forEach((row, r) => {
            Array.from(row.cells).forEach((cell, c) => {
                cell.classList.remove('highlight-row', 'highlight-col', 'flash');
                if (r === activeHandIndex) rowCells.push(cell);
                if (c === activeBetIndex) colCells.push(cell);
            });
        });

        // Apply new highlights
        rowCells.forEach(cell => {
            cell.classList.add('highlight-row');
            if (State.isDeal) cell.classList.add('flash');
        });

        colCells.forEach(cell => {
            cell.classList.add('highlight-col');
        });

        // Remove flash after a timer
        if (State.isDeal) {
            setTimeout(() => {
            rowCells.forEach(cell => cell.classList.remove('flash'));
            }, 3000);
        }
    }

    function renderHand(hand) {
        const handEl = UI.hand;
        handEl.innerHTML = '';

        // Empty hand → show backs
        if (hand.length === 0) {
            for (let i = 0; i < DEFAULTS.HAND_SIZE; i++) {
                const back = document.createElement('div');
                back.className = 'card back';
                handEl.appendChild(back);
            }

            updateHandLayout();
            return;
        }

        hand.forEach((card, index) => {
            handEl.appendChild(createCardElement(card, index));
        });

        updateHandLayout();
    }

    function createCardElement(card, index) {
        const cardDiv = document.createElement('div');
        cardDiv.className = 'card';
        cardDiv.dataset.index = index;

        if (card.held) cardDiv.classList.add('held');
        if (card.suit === '♥' || card.suit === '♦') {
            cardDiv.classList.add('red');
        }

        // ── Top corner ─────────────────────────────
        const topCorner = document.createElement('div');
        topCorner.className = 'corner top';

        const topRank = document.createElement('span');
        topRank.className = 'rank';
        topRank.textContent = card.rank;

        const topSuit = document.createElement('span');
        topSuit.className = 'suit';
        topSuit.textContent = card.suit;

        topCorner.append(topRank, topSuit);

        // ── Center ─────────────────────────────────
        const center = document.createElement('div');
        center.className = 'center';
        center.textContent = card.suit; // placeholder (pip / face later)

        // ── Bottom corner (mirrored) ───────────────
        const bottomCorner = document.createElement('div');
        bottomCorner.className = 'corner bottom';

        const bottomRank = document.createElement('span');
        bottomRank.className = 'rank';
        bottomRank.textContent = card.rank;

        const bottomSuit = document.createElement('span');
        bottomSuit.className = 'suit';
        bottomSuit.textContent = card.suit;

        bottomCorner.append(bottomRank, bottomSuit);

        // ── Assemble ───────────────────────────────
        cardDiv.append(topCorner, center, bottomCorner);

        return cardDiv;
    }

    function pulseCredits() {
        const el = UI.credits 
        let start = State.credits - State.win
        let stop = State.credits

        const interval = setInterval(() => {
            start++
            el.textContent = `CREDITS ${start}`

            el.classList.remove('pulse')
            void el.offsetWidth
            el.classList.add('pulse')

            // vibrate on each tick (if supported)
            if (navigator.vibrate) {
                navigator.vibrate(50); // 50ms vibration each tick
            }

            if (start >= stop) clearInterval(interval)
        }, 120)
    }

    function dispatch(action, ...args){
        action(...args)
        render()
    }
    
    function cycleBet() {
        clearRoundStat()
        State.bet = State.bet % DEFAULTS.MAX_BET + 1
    }

    function maxBet(){
        clearRoundStat()
        State.bet = DEFAULTS.MAX_BET;
    }

    function handleDeal() {
        // Deal phase
        if (State.isDeal){
            clearRoundStat()
            State.credits -= State.bet 
            State.deck = createDeck(DEFAULTS.SUITS, DEFAULTS.RANKS, DEFAULTS.VALUES)
            shuffleDeck(State.deck)
            State.hand = State.deck.splice(0, DEFAULTS.HAND_SIZE)
        }
        // Draw phase
        else {
            drawCards(State.hand, State.deck)
            // clearHolds()
        }
        
        if (State.hand){
            const r = evaluateHand(State.hand)
            if(r.handRank){
                State.currentHandRank = r.handRank.name
                if(!State.isDeal){
                    State.win = r.handRank.payout[State.bet - 1] ?? 0
                    State.wonIndices = r.winningIndexes
                }
            }
            else State.win = 0
        }   
        if (!State.isDeal && State.win) State.credits += State.win
        State.isDeal = !State.isDeal 
    }

    function clearRoundStat(){
        State.currentHandRank = null
        State.win = null
        State.wonIndices = []
    }

    function createDeck(suits, ranks, values){
        return suits.flatMap(s => ranks.map(r => ({
            suit: s,  
            rank: r,
            value: values[r]
        })))
    }

    function shuffleDeck(deck){
        for(let i=deck.length-1;i>0;i--){
            const j=Math.floor(Math.random()*(i+1))
            ;[deck[i],deck[j]]=[deck[j],deck[i]]
        }
    }

    function drawCards(hand, deck){
        hand.forEach((card, i)=>{
            if(!card.held){
                hand[i]=deck.splice(0, 1)[0]
            }
        })
    }

    function evaluateHand(hand) {
        const cards = hand.map((card, index) => ({...card,index}));

        const isFlush = hand.every(h => h.suit === hand[0].suit);
        const sortedValues = cards.map(c => c.value).sort((a, b) => a - b)

        const rankMap = {};
        for (const c of cards) {
            rankMap[c.value] ??= [];  // If rankMap[c.value] does not exist yet, create it as an empty array.
            rankMap[c.value].push(c.index);  // Card index pushed to array
        }

        const uniqueValues = Object.keys(rankMap)
            .map(Number)
            .sort((a, b) => a - b);

        const counts = Object.values(rankMap)
            .map(a => a.length)
            .sort((a, b) => b - a);

        const isStraight =
            uniqueValues.length === 5 &&
            (
                sortedValues.toString() === "2,3,4,5,14" ||  // Lowest straight with Ace case
                sortedValues.every((v, i) => i === 0 || v === sortedValues[i - 1] + 1)
            );

        const ctx = {
            cards,
            sortedValues,
            uniqueValues,
            rankMap,
            counts,
            isFlush,
            isStraight,
            allIndexes: cards.map(c => c.index)
        };

        // sort once, highest priority first
        const rulesByPriority = HAND_RULES
            .slice()
            .sort((a, b) => b.priority - a.priority);

        for (const rule of rulesByPriority) {
            if (rule.test(ctx)) {
                return {
                    handRank: rule.rank,
                    winningIndexes: rule.indexes(ctx)
                };
            }
        }

        return {
            handRank: null,
            winningIndexes: []
        };
    }

    function handleHold(index){
        if(State.isDeal) return
        const card = State.hand[index]
        card.held = !card.held
    }

    function updateHandLayout() {
        const cards = Array.from(UI.hand.children); //
        if (cards.length === 0) return; //
        
        const handWidth = UI.hand.clientWidth;
        const cardWidth = cards[0].offsetWidth;
        const cardsCount = cards.length;

        const totalWidth = cardWidth * cardsCount;  //
        let overlap = 0; //

        if (totalWidth > handWidth) {
            overlap = (totalWidth - handWidth) / (cardsCount-1);
            overlap = Math.min(overlap, cardWidth);

            // Optional: ensure minimum visible portion (30px)
            // const MIN_VISIBLE = 30;
            // overlap = Math.min(overlap, cardWidth - MIN_VISIBLE);
        }

        cards.forEach((card, index) => {
            card.style.marginLeft = index === 0 ? '0px' : `-${overlap}px`;
            // card.style.transform = index === 0 ? 'translateX(0)' : `translateX(${-overlap}px)`;
            card.style.zIndex = index; // ensures proper stacking
        });
    }

    function updateViewportSize(){
        UI.viewport.textContent=`Viewport size: ${window.innerWidth} * ${window.innerHeight}`
    }

    function debounce(fn, delay = 100) {
        let timer;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => fn(...args), delay);
        };
    }

    window.addEventListener(
        "resize",
        debounce(() => {
            updateHandLayout();
            updateViewportSize();
            updateUserData();
            updateViewportSize();
        }, 100)
    );

    document.addEventListener("DOMContentLoaded", () => {
         UI = {
            table: document.getElementById('paytable'),
            win: document.getElementById("win"),
            credits: document.getElementById("credits"),
            banner: document.getElementById("banner"),
            betOneBtn: document.getElementById("betOneBtn"),
            betMaxBtn: document.getElementById("betMaxBtn"),
            dealBtn: document.getElementById("dealBtn"),
            resetBtn: document.getElementById("resetBtn"),
            hand: document.getElementById("hand"),
            viewport: document.getElementById('viewport')
        };


        
        // attach listeners AFTER UI is built
        UI.betOneBtn.addEventListener("click", () => dispatch(cycleBet));
        UI.betMaxBtn.addEventListener("click", () => dispatch(maxBet));
        UI.dealBtn.addEventListener("click", () => dispatch(handleDeal));
        UI.hand.addEventListener("click", (e) => {
            const card = e.target.closest(".card");
            if (!card) return;
            dispatch(handleHold, +card.dataset.index);
        });

        updateViewportSize()
        renderPaytable(HAND_RANKS)
        render()
    });

</script>
</body>
</html>
